spring:
  application:
    name: service-a-backend
  lifecycle:
    timeout-per-shutdown-phase: 20s
  jpa:
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    hibernate:
      ddl-auto: update # create update
    show-sql: false
    properties:
      hibernate:
        format_sql: true

  datasource:
    hikari:
      maximum-pool-size: 50              # 풀 크기(동시 DB 커넥션 상한)
      minimum-idle: 10                   # 유휴 커넥션 유지
      connection-timeout: 5000           # 풀 고갈 시 5초 대기 후 예외(획득 실패)
      validation-timeout: 2000           # 커넥션 검증 타임아웃
      leak-detection-threshold: 10000    # 장기 점유 감지(디버깅용)
  data:
    redis:
      timeout: 1000ms
      lettuce:
        pool:
          max-active: 55   # Redis 동시 연결 최대 수
          max-idle: 10     # 유휴 연결 최대 유지 수
          min-idle: 2      # 최소 유휴 연결 유지 수

  # Vault 설정을 최우선으로 가져오도록 명시
  config:
    import: "optional:vault://"

  cloud:
    vault:
      uri: ${VAULT_URI:http://vault:8200}
      authentication: APPROLE
      app-role:
        role-id: ${VAULT_ROLE_ID}
        secret-id: ${VAULT_SECRET_ID}
        role: service-a-backend
        app-role-path: approle
      kv:
        enabled: true
        backend: secret
        application-name: service-a-backend
        # 공통 경로(/application) 탐색을 비활성화
        default-context: service-a-backend
        profiles: []
      # Vault 일시 불가 시 앱 기동 실패 방지
      fail-fast: false
      config:
        lifecycle:
          enabled: true
          # 갱신 실패(max_ttl 도달 등) 시 token renew 대신 AppRole 재인증 수행
          # → retry storm 근본 차단: 갱신 루프 대신 새 토큰으로 즉시 복구
          renewal-mode: re_authenticate
          # 갱신 시도 최소 간격 (10초 미만 재시도 금지)
          min-renewal: 10s
          # 만료 15초 전부터 사전 갱신 시작
          expiry-threshold: 15s

server:
  port: 8080
  shutdown: graceful

management:
  health:
    circuitbreakers:
      enabled: true # 서킷 브레이커 상태를 /actuator/health에 포함
    redis:
      enabled: true
  endpoints:
    web:
      exposure:
        include: "health,prometheus,metrics,circuitbreakers"
  metrics:
    tags:
      application: ${spring.application.name}

resilience4j.circuitbreaker:
  configs:
    default: # 공통 설정
      # 최근 호출 기준 설정
      sliding-window-type: COUNT_BASED
      sliding-window-size: 100 # 최근 100건 기반 평가
      minimum-number-of-calls: 70 # 70건 쌓여야 평가 시작
      failure-rate-threshold: 50 # 실패율 50% 이상이면 OPEN
  instances:
    testCircuit:
      baseConfig: default
      automatic-transition-from-open-to-half-open-enabled: true # 자동 전환 옵션
      register-health-indicator: true
      slow-call-duration-threshold: 3000 # 3초 초과는 slow-call로 분류
      slow-call-rate-threshold: 50       # slow-call 비율 50% 이상이면 OPEN
      wait-duration-in-open-state: 10s   # OPEN 후 10초 뒤 HALF_OPEN
      # HALF_OPEN 상태에서 허용 호출 수
      permitted-number-of-calls-in-half-open-state: 10
      # 예외 기록 기준
      record-exceptions:
        - java.sql.SQLException
        - org.springframework.dao.DataAccessException
        - org.springframework.jdbc.CannotGetJdbcConnectionException
        - org.springframework.transaction.CannotCreateTransactionException
        - org.hibernate.exception.JDBCConnectionException
        - java.util.concurrent.TimeoutException
      # 성공으로 간주할 예외
      ignore-exceptions:
        - com.exit8.exception.ApiException
        - org.springframework.web.bind.MethodArgumentNotValidException
        - org.springframework.web.bind.MissingServletRequestParameterException

# Rate Limit 적용
rate-limit:
  enabled: ${RATE_LIMIT_ENABLED:false} # 환경변수로 조절 가능하게 설정

# Redis 적용
redis-cache:
  enabled: ${REDIS_CACHE_ENABLED:false}
  ttl-seconds: 300 # TTL 5분
